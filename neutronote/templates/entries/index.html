{% extends "base.html" %}

{% block title %}Notebook ‚Äì neutroNote{% endblock %}

{% block content %}
<!-- IPTS Setup Modal -->
<div class="setup-overlay" id="setup-overlay" {% if config.is_configured %}style="display: none;"{% endif %}>
    <div class="setup-modal">
        <div class="setup-header">
            <h2>üìì Configure Notebook</h2>
            {% if config.is_configured %}
            <button type="button" class="btn-close" onclick="document.getElementById('setup-overlay').style.display='none'">√ó</button>
            {% endif %}
        </div>
        <p>Enter the IPTS number for this experiment notebook. This will be used for all run header lookups.</p>
        
        <form action="{{ url_for('entries.setup_notebook') }}" method="post">
            <div class="form-group">
                <label for="setup-ipts">IPTS Number <span class="required">*</span></label>
                <input type="text" id="setup-ipts" name="ipts" placeholder="e.g., IPTS-12345 or 12345" value="{{ config.ipts or '' }}" required {% if not config.is_configured %}autofocus{% endif %}>
                <small class="form-hint">Enter with or without "IPTS-" prefix.</small>
            </div>
            <div class="form-group">
                <label for="setup-title">Notebook Title (optional)</label>
                <input type="text" id="setup-title" name="notebook_title" placeholder="e.g., Diamond Anvil Calibration" value="{{ config.title or '' }}">
            </div>
            <button type="submit" class="btn btn-primary btn-large">{% if config.is_configured %}Update{% else %}Start Notebook{% endif %}</button>
        </form>
    </div>
</div>

<div class="split-view">
    <!-- LEFT PANEL: Entry Creation -->
    <aside class="create-panel">
        <h2>Create Entry</h2>
        
        <!-- Flash messages (errors, etc.) -->
        {% with messages = get_flashed_messages(with_categories=true) %}
            {% if messages %}
                <div class="flash-messages">
                    {% for category, message in messages %}
                        <div class="flash-message flash-{{ category }}">
                            {{ message }}
                            <button type="button" class="flash-close" onclick="this.parentElement.remove()">√ó</button>
                        </div>
                    {% endfor %}
                </div>
            {% endif %}
        {% endwith %}
        
        <!-- Entry type tabs -->
        <div class="entry-type-tabs">
            <button class="tab active" data-type="text">Text</button>
            <button class="tab" data-type="header" {% if not config.is_configured %}disabled title="Configure IPTS first"{% endif %}>Header</button>
            <button class="tab" data-type="image">Image</button>
            <button class="tab" data-type="data" {% if not config.is_configured %}disabled title="Configure IPTS first"{% endif %}>Data</button>
            <button class="tab" data-type="code" disabled title="Coming soon">Code</button>
        </div>

        <!-- Text entry form -->
        <form id="text-form" class="entry-form active" action="{{ url_for('entries.create_text') }}" method="post">
            <div class="form-group">
                <label for="title">Title (optional)</label>
                <input type="text" id="title" name="title" placeholder="Entry title...">
            </div>
            <div class="form-group">
                <label for="body">Content</label>
                <textarea id="body" name="body" rows="8" placeholder="Write your notes here... (Markdown supported, use $...$ for inline math)" required></textarea>
            </div>
            <button type="submit" class="btn btn-primary">Submit Entry</button>
        </form>

        <!-- Run Header entry form -->
        <form id="header-form" class="entry-form" action="{{ url_for('entries.create_header') }}" method="post">
            {% if config.is_configured %}
            <div class="form-group">
                <label for="run_number">Run Number</label>
                <input type="number" id="run_number" name="run_number" placeholder="e.g., 67890" required min="1">
                <small class="form-hint">Fetch run metadata from {{ config.ipts }}</small>
            </div>
            <button type="submit" class="btn btn-primary">Fetch Run Header</button>
            {% else %}
            <p class="placeholder-text">Please configure the notebook IPTS first.</p>
            {% endif %}
        </form>

        <!-- Image upload form -->
        <form id="image-form" class="entry-form" action="{{ url_for('entries.create_image') }}" method="post" enctype="multipart/form-data">
            <div class="form-group">
                <label for="image">Select Image</label>
                <input type="file" id="image" name="image" accept="image/*" required>
                <small class="form-hint">Supported formats: PNG, JPG, GIF, WebP, SVG (max 16 MB)</small>
            </div>
            <div class="form-group">
                <label for="caption">Caption (optional)</label>
                <input type="text" id="caption" name="caption" placeholder="Image caption...">
            </div>
            <button type="submit" class="btn btn-primary">Upload Image</button>
        </form>

        <!-- Reduced Data entry form -->
        <form id="data-form" class="entry-form">
            {% if config.is_configured %}
            <div class="form-group">
                <label for="state-select">Instrument State</label>
                <select id="state-select" name="state_id" required>
                    <option value="">Loading states...</option>
                </select>
                <small class="form-hint">Select the instrument configuration state</small>
            </div>
            
            <div id="selected-run-info" class="selected-run-info" style="display: none;">
                <div class="selected-run-header">
                    <strong>Selected Run</strong>
                    <button type="button" class="btn-clear-selection" onclick="clearRunSelection()">‚úï</button>
                </div>
                <div class="selected-run-details">
                    <span class="selected-run-number" id="selected-run-number"></span>
                    <span class="selected-run-title" id="selected-run-title"></span>
                </div>
                <div class="selected-run-meta">
                    <span id="selected-run-duration"></span> ¬∑ <span id="selected-run-timestamp"></span>
                </div>
            </div>
            
            <button type="button" class="btn btn-secondary" id="browse-runs-btn" onclick="openRunBrowser()">
                üìÇ Browse Reduced Runs
            </button>
            
            <input type="hidden" id="selected-run" name="run_number" value="">
            <input type="hidden" id="selected-state" name="state_id" value="">
            
            <button type="submit" class="btn btn-primary" id="data-submit-btn" disabled>
                View Reduced Data
            </button>
            {% else %}
            <p class="placeholder-text">Please configure the notebook IPTS first.</p>
            {% endif %}
        </form>
        
        <form id="code-form" class="entry-form" style="display:none;">
            <p class="placeholder-text">Code entry form coming in Phase 4...</p>
        </form>
    </aside>

<!-- Run Browser Modal -->
<div id="run-browser-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content modal-large">
        <div class="modal-header">
            <h3>üìÇ Browse Reduced Runs</h3>
            <button type="button" class="btn-close" onclick="closeRunBrowser()">√ó</button>
        </div>
        
        <div class="modal-filters">
            <div class="filter-row">
                <div class="filter-group">
                    <label for="filter-search">Search Title</label>
                    <input type="text" id="filter-search" placeholder="Filter by title...">
                </div>
                <div class="filter-group">
                    <label for="filter-duration">Min Duration</label>
                    <select id="filter-duration">
                        <option value="0">All runs</option>
                        <option value="60">‚â• 1 minute</option>
                        <option value="300">‚â• 5 minutes</option>
                        <option value="600">‚â• 10 minutes</option>
                        <option value="1800">‚â• 30 minutes</option>
                        <option value="3600">‚â• 1 hour</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="filter-run">Run Number</label>
                    <input type="text" id="filter-run" placeholder="e.g., 65890">
                </div>
            </div>
            <div class="filter-summary">
                Showing <span id="filter-count">0</span> of <span id="total-count">0</span> runs
            </div>
        </div>
        
        <div class="modal-body">
            <table class="run-table" id="run-table">
                <thead>
                    <tr>
                        <th class="checkbox-col"><input type="checkbox" id="select-all-runs" title="Select all visible runs"></th>
                        <th class="sortable" data-sort="run_number">Run # <span class="sort-indicator"></span></th>
                        <th class="sortable" data-sort="title">Title <span class="sort-indicator"></span></th>
                        <th class="sortable" data-sort="duration">Duration <span class="sort-indicator"></span></th>
                        <th class="sortable" data-sort="start_time">Start Time <span class="sort-indicator"></span></th>
                    </tr>
                </thead>
                <tbody id="run-table-body">
                    <tr><td colspan="5" class="loading-row">Loading runs...</td></tr>
                </tbody>
            </table>
        </div>
        
        <div class="modal-footer">
            <div class="selection-info">
                <span id="selected-count">0</span> run(s) selected
            </div>
            <button type="button" class="btn btn-secondary" onclick="closeRunBrowser()">Cancel</button>
            <button type="button" class="btn btn-primary" id="select-run-btn" disabled onclick="confirmRunSelectionAndView()">
                View Run(s)
            </button>
        </div>
    </div>
</div>

<!-- Plot Viewer Modal -->
<div id="plot-viewer-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content modal-fullscreen">
        <div class="modal-header">
            <h3 id="plot-viewer-title">üìä Reduced Data</h3>
            <button type="button" class="btn-close" onclick="closePlotViewer()">√ó</button>
        </div>
        
        <div class="plot-controls">
            <div class="control-group">
                <label>Grouping</label>
                <select id="workspace-select">
                    <option value="dsp_all">Combined (All Pixels)</option>
                    <option value="dsp_bank">Per Bank (2 spectra)</option>
                    <option value="dsp_column">Per Column (6 spectra)</option>
                </select>
            </div>
            
            <div class="control-group spectrum-checkboxes" id="spectrum-select-group" style="display: none;">
                <label>Spectra</label>
                <div class="checkbox-group" id="spectrum-checkboxes">
                    <!-- Populated dynamically based on workspace -->
                </div>
            </div>
            
            <div class="control-group control-group-spacer"></div>
            
            <button type="button" class="btn btn-secondary" id="add-to-timeline-btn" onclick="addPlotToTimeline()">
                üìù Add to Timeline
            </button>
        </div>
        
        <div class="modal-body plot-body">
            <div id="plot-container" class="plot-container">
                <div class="loading-spinner">Loading plot data...</div>
            </div>
        </div>
        
        <div class="plot-info">
            <span id="plot-run-info"></span>
            <span id="plot-file-info"></span>
        </div>
    </div>
</div>

    <!-- RIGHT PANEL: Timeline -->
    <section class="timeline-panel">
        <!-- Notebook IPTS banner -->
        {% if config.is_configured %}
        <div class="notebook-info">
            <span class="ipts-badge">{{ config.ipts }}</span>
            {% if config.title %}
            <span class="notebook-title">{{ config.title }}</span>
            {% endif %}
            <button type="button" class="btn-settings" onclick="document.getElementById('setup-overlay').style.display='flex'" title="Change IPTS">‚öôÔ∏è</button>
        </div>
        {% endif %}
        
        <div class="timeline-header">
            <h2>Timeline</h2>
            <!-- Dev tools - remove in production -->
            <button type="button" class="btn btn-sm btn-danger" onclick="resetTimeline()" title="DEV: Clear all entries">üóëÔ∏è Reset</button>
        </div>
        
        <div class="timeline" id="timeline">
            {% if entries %}
                {% for entry in entries %}
                    {% include "entries/_entry_card.html" %}
                {% endfor %}
            {% else %}
                <p class="empty-state">No entries yet. Create your first entry on the left!</p>
            {% endif %}
        </div>
    </section>
</div>
{% endblock %}

{% block scripts %}
<script>
// Function to switch to a specific tab
function switchToTab(type) {
    const tab = document.querySelector(`.tab[data-type="${type}"]`);
    if (!tab || tab.disabled) return;
    
    // Update active tab
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    tab.classList.add('active');
    
    // Hide all forms, show the selected one
    document.querySelectorAll('.entry-form').forEach(f => {
        f.style.display = 'none';
        f.classList.remove('active');
    });
    const form = document.getElementById(type + '-form');
    form.style.display = 'block';
    form.classList.add('active');
    
    // Load states when switching to data tab (use direct DOM lookup since stateSelect may not be defined yet)
    if (type === 'data') {
        const stateSelectEl = document.getElementById('state-select');
        if (stateSelectEl && stateSelectEl.options.length <= 1 && typeof loadStates === 'function') {
            loadStates();
        }
    }
}

// Tab switching for entry types
document.querySelectorAll('.entry-type-tabs .tab').forEach(tab => {
    tab.addEventListener('click', function() {
        if (this.disabled) return;
        switchToTab(this.dataset.type);
    });
});

// Check for tab parameter in URL (to stay on tab after error)
const urlParams = new URLSearchParams(window.location.search);
const tabParam = urlParams.get('tab');
if (tabParam) {
    switchToTab(tabParam);
}

// Auto-scroll timeline to bottom (newest entries)
const timeline = document.getElementById('timeline');
timeline.scrollTop = timeline.scrollHeight;

// =============================================================================
// Dev Tools
// =============================================================================

function resetTimeline() {
    if (!confirm('‚ö†Ô∏è DEV MODE: Delete ALL entries from the timeline? This cannot be undone!')) {
        return;
    }
    
    fetch('/entries/api/dev/reset-timeline', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'}
    })
    .then(res => res.json())
    .then(data => {
        if (data.success) {
            alert(`Deleted ${data.deleted_count} entries. Reloading page...`);
            window.location.reload();
        } else {
            alert('Error: ' + (data.error || 'Failed to reset timeline'));
        }
    })
    .catch(err => {
        console.error('Reset failed:', err);
        alert('Failed to reset timeline');
    });
}

// =============================================================================
// Reduced Data Selection Logic
// =============================================================================

const stateSelect = document.getElementById('state-select');
const selectedRunInfo = document.getElementById('selected-run-info');
const selectedRunNumber = document.getElementById('selected-run-number');
const selectedRunTimestamp = document.getElementById('selected-run-timestamp');
const selectedRunInput = document.getElementById('selected-run');
const selectedStateInput = document.getElementById('selected-state');
const dataSubmitBtn = document.getElementById('data-submit-btn');

let allRuns = [];  // Cache of runs for current state
let selectedRun = null;  // Single selected run (backward compat)
let selectedRuns = [];   // Array of selected runs (multi-select)

// Load states when data tab is clicked
function loadStates() {
    if (!stateSelect) return;
    
    stateSelect.innerHTML = '<option value="">Loading...</option>';
    
    fetch('/entries/api/states')
        .then(res => res.json())
        .then(data => {
            if (data.error) {
                stateSelect.innerHTML = `<option value="">Error: ${data.error}</option>`;
                return;
            }
            
            if (!data.states || data.states.length === 0) {
                stateSelect.innerHTML = '<option value="">No reduced data found</option>';
                return;
            }
            
            stateSelect.innerHTML = '<option value="">Select a state...</option>';
            data.states.forEach(stateId => {
                const opt = document.createElement('option');
                opt.value = stateId;
                // Show abbreviated state ID for display
                opt.textContent = `State: ${stateId.substring(0, 8)}...`;
                stateSelect.appendChild(opt);
            });
            
            // Auto-select if only one state
            if (data.states.length === 1) {
                stateSelect.value = data.states[0];
                selectedStateInput.value = data.states[0];
            }
        })
        .catch(err => {
            console.error('Failed to load states:', err);
            stateSelect.innerHTML = '<option value="">Failed to load states</option>';
        });
}

// State selection change - just update the hidden input, runs are loaded in modal
if (stateSelect) {
    stateSelect.addEventListener('change', function() {
        selectedRun = null;
        selectedRunInfo.style.display = 'none';
        dataSubmitBtn.disabled = true;
        selectedRunInput.value = '';
        selectedStateInput.value = this.value;
        allRuns = [];  // Clear cached runs so modal reloads them
    });
}

// Load states when switching to data tab
document.querySelector('.tab[data-type="data"]')?.addEventListener('click', function() {
    if (!this.disabled && stateSelect && stateSelect.options.length <= 1) {
        loadStates();
    }
});

// Load states on initial page load if data tab is active
const dataTab = document.querySelector('.tab[data-type="data"]');
if (dataTab && dataTab.classList.contains('active') && stateSelect && stateSelect.options.length <= 1) {
    loadStates();
}

// =============================================================================
// Run Browser Modal Logic
// =============================================================================

const runBrowserModal = document.getElementById('run-browser-modal');
const runTableBody = document.getElementById('run-table-body');
const filterSearch = document.getElementById('filter-search');
const filterDuration = document.getElementById('filter-duration');
const filterRun = document.getElementById('filter-run');
const filterCount = document.getElementById('filter-count');
const totalCount = document.getElementById('total-count');
const selectRunBtn = document.getElementById('select-run-btn');

let browserRuns = [];  // All runs loaded in the browser
let filteredRuns = [];  // Current filtered view
let browserSelectedRuns = [];  // Array of selected runs in modal (multi-select)
let sortColumn = 'run_number';
let sortDirection = 'asc';

// Open the run browser modal
function openRunBrowser() {
    if (!stateSelect || !stateSelect.value) {
        alert('Please select an instrument state first');
        return;
    }
    
    runBrowserModal.style.display = 'flex';
    browserSelectedRuns = [];
    updateSelectionCount();
    selectRunBtn.disabled = true;
    
    // Reset filters
    filterSearch.value = '';
    filterDuration.value = '0';
    filterRun.value = '';
    
    // Load runs if not already loaded
    if (allRuns.length > 0) {
        browserRuns = allRuns;
        applyFiltersAndSort();
    } else {
        loadRunsForBrowser();
    }
}

// Close the run browser modal
function closeRunBrowser() {
    runBrowserModal.style.display = 'none';
}

// Load runs specifically for the browser
function loadRunsForBrowser() {
    const stateId = stateSelect.value;
    runTableBody.innerHTML = '<tr><td colspan="4" class="loading-row">Loading runs...</td></tr>';
    
    fetch(`/entries/api/states/${stateId}/runs`)
        .then(res => res.json())
        .then(data => {
            if (data.error) {
                runTableBody.innerHTML = `<tr><td colspan="4" class="loading-row">Error: ${data.error}</td></tr>`;
                return;
            }
            browserRuns = data.runs;
            allRuns = data.runs;  // Update the cache
            applyFiltersAndSort();
        })
        .catch(err => {
            runTableBody.innerHTML = '<tr><td colspan="4" class="loading-row">Failed to load runs</td></tr>';
            console.error('Failed to load runs:', err);
        });
}

// Apply current filters and sorting
function applyFiltersAndSort() {
    const searchQuery = filterSearch.value.toLowerCase().trim();
    const minDuration = parseInt(filterDuration.value) || 0;
    const runQuery = filterRun.value.trim();
    
    // Filter
    filteredRuns = browserRuns.filter(run => {
        // Title search
        if (searchQuery && !(run.title || '').toLowerCase().includes(searchQuery)) {
            return false;
        }
        // Duration filter
        if (minDuration > 0 && (run.duration || 0) < minDuration) {
            return false;
        }
        // Run number filter
        if (runQuery && !String(run.run_number).includes(runQuery)) {
            return false;
        }
        return true;
    });
    
    // Sort
    filteredRuns.sort((a, b) => {
        let aVal = a[sortColumn];
        let bVal = b[sortColumn];
        
        // Handle null/undefined
        if (aVal == null) aVal = sortColumn === 'title' ? '' : 0;
        if (bVal == null) bVal = sortColumn === 'title' ? '' : 0;
        
        // String comparison for title
        if (sortColumn === 'title') {
            aVal = aVal.toLowerCase();
            bVal = bVal.toLowerCase();
        }
        
        let cmp = 0;
        if (aVal < bVal) cmp = -1;
        else if (aVal > bVal) cmp = 1;
        
        return sortDirection === 'asc' ? cmp : -cmp;
    });
    
    // Update counts
    totalCount.textContent = browserRuns.length;
    filterCount.textContent = filteredRuns.length;
    
    // Render table
    renderRunTable();
}

// Render the run table
function renderRunTable() {
    if (filteredRuns.length === 0) {
        runTableBody.innerHTML = '<tr><td colspan="5" class="loading-row">No runs match the current filters</td></tr>';
        return;
    }
    
    // Collect runs that need metadata loading
    const runsNeedingMetadata = [];
    
    runTableBody.innerHTML = '';
    filteredRuns.forEach(run => {
        const row = document.createElement('tr');
        row.className = 'run-row';
        row.dataset.runNumber = run.run_number;
        
        // Check if this run is selected
        const isSelected = browserSelectedRuns.some(r => r.run_number === run.run_number);
        if (isSelected) {
            row.classList.add('selected');
        }
        
        // Show loading indicator if metadata not yet loaded
        const hasMetadata = run._metadataLoaded;
        const titleDisplay = hasMetadata ? escapeHtml(run.title || '‚Äî') : '<span class="loading-text">loading...</span>';
        const durationDisplay = hasMetadata ? (run.duration_display || '‚Äî') : '...';
        const timeDisplay = hasMetadata ? (run.start_time_display || run.timestamp_display || '‚Äî') : '...';
        
        row.innerHTML = `
            <td class="checkbox-cell"><input type="checkbox" class="run-checkbox" data-run="${run.run_number}" ${isSelected ? 'checked' : ''}></td>
            <td class="run-number-cell">${run.run_number}</td>
            <td class="title-cell" title="${escapeHtml(run.title || '')}">${titleDisplay}</td>
            <td class="duration-cell">${durationDisplay}</td>
            <td class="timestamp-cell">${timeDisplay}</td>
        `;
        
        // Checkbox change handler
        const checkbox = row.querySelector('.run-checkbox');
        checkbox.addEventListener('change', (e) => {
            e.stopPropagation();
            toggleRunSelection(run, row, checkbox.checked);
        });
        
        // Row click toggles selection
        row.addEventListener('click', (e) => {
            if (e.target.type !== 'checkbox') {
                checkbox.checked = !checkbox.checked;
                toggleRunSelection(run, row, checkbox.checked);
            }
        });
        
        // Double click to select just this run and open plot viewer
        row.addEventListener('dblclick', (e) => {
            if (e.target.type === 'checkbox') return;
            browserSelectedRuns = [run];  // Select only this run
            updateSelectionCount();
            confirmRunSelectionAndView();
        });
        
        runTableBody.appendChild(row);
        
        // Track runs needing metadata
        if (!hasMetadata && !run._metadataLoading) {
            run._metadataLoading = true;
            runsNeedingMetadata.push(run.run_number);
        }
    });
    
    // Update select-all checkbox state
    updateSelectAllCheckbox();
    
    // Update sort indicators
    document.querySelectorAll('.run-table th').forEach(th => {
        th.classList.remove('sorted-asc', 'sorted-desc');
        if (th.dataset.sort === sortColumn) {
            th.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
        }
    });
    
    // Batch load metadata for visible runs
    if (runsNeedingMetadata.length > 0) {
        loadMetadataBatch(runsNeedingMetadata);
    }
}

// Toggle run selection
function toggleRunSelection(run, row, selected) {
    if (selected) {
        if (!browserSelectedRuns.some(r => r.run_number === run.run_number)) {
            browserSelectedRuns.push(run);
        }
        row.classList.add('selected');
    } else {
        browserSelectedRuns = browserSelectedRuns.filter(r => r.run_number !== run.run_number);
        row.classList.remove('selected');
    }
    updateSelectionCount();
    updateSelectAllCheckbox();
}

// Update selection count display
function updateSelectionCount() {
    document.getElementById('selected-count').textContent = browserSelectedRuns.length;
    selectRunBtn.disabled = browserSelectedRuns.length === 0;
}

// Update select-all checkbox state
function updateSelectAllCheckbox() {
    const selectAll = document.getElementById('select-all-runs');
    if (!selectAll) return;
    
    const allSelected = filteredRuns.length > 0 && 
        filteredRuns.every(run => browserSelectedRuns.some(r => r.run_number === run.run_number));
    const someSelected = browserSelectedRuns.length > 0 && !allSelected;
    
    selectAll.checked = allSelected;
    selectAll.indeterminate = someSelected;
}

// Batch load metadata for multiple runs
function loadMetadataBatch(runNumbers) {
    fetch('/entries/api/runs/metadata/batch', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({run_numbers: runNumbers})
    })
    .then(res => res.json())
    .then(data => {
        if (data.metadata) {
            // Update all runs with received metadata
            for (const [runNum, meta] of Object.entries(data.metadata)) {
                const run = allRuns.find(r => r.run_number === parseInt(runNum));
                if (run) {
                    run.title = meta.title || '';
                    run.duration = meta.duration || 0;
                    run.start_time = meta.start_time || '';
                    run._metadataLoaded = true;
                    
                    // Format display values
                    const sec = run.duration;
                    if (sec < 60) run.duration_display = `${sec.toFixed(0)} sec`;
                    else if (sec < 3600) run.duration_display = `${(sec/60).toFixed(1)} min`;
                    else run.duration_display = `${(sec/3600).toFixed(1)} hr`;
                    
                    if (run.start_time) {
                        try {
                            const dt = run.start_time.substring(0, 19);
                            run.start_time_display = dt.replace('T', ' ').substring(0, 16);
                        } catch(e) {
                            run.start_time_display = run.start_time;
                        }
                    }
                    
                    // Update the row in the table
                    updateRunRowDisplay(run);
                }
            }
        }
    })
    .catch(err => console.error('Failed to load metadata batch:', err));
}

// Update a single row's display after metadata loads
function updateRunRowDisplay(run) {
    const row = runTableBody.querySelector(`tr[data-run-number="${run.run_number}"]`);
    if (!row) return;
    
    const cells = row.querySelectorAll('td');
    if (cells.length >= 5) {
        cells[2].textContent = run.title || '‚Äî';
        cells[2].title = run.title || '';
        cells[3].textContent = run.duration_display || '‚Äî';
        cells[4].textContent = run.start_time_display || run.timestamp_display || '‚Äî';
    }
}

// Confirm run selection from browser (multi-select)
function confirmRunSelection() {
    if (browserSelectedRuns.length === 0) return;
    
    // Store selected runs
    selectedRuns = [...browserSelectedRuns];
    selectedRun = selectedRuns[0];  // Keep backward compat
    selectedRunInput.value = selectedRuns.map(r => r.run_number).join(',');
    
    // Update selection display
    if (selectedRuns.length === 1) {
        selectedRunNumber.textContent = selectedRuns[0].run_number;
        document.getElementById('selected-run-title').textContent = selectedRuns[0].title || '‚Äî';
        document.getElementById('selected-run-duration').textContent = selectedRuns[0].duration_display || '‚Äî';
        document.getElementById('selected-run-timestamp').textContent = selectedRuns[0].start_time_display || selectedRuns[0].timestamp_display || '‚Äî';
    } else {
        selectedRunNumber.textContent = selectedRuns.map(r => r.run_number).join(', ');
        document.getElementById('selected-run-title').textContent = `${selectedRuns.length} runs selected`;
        document.getElementById('selected-run-duration').textContent = '‚Äî';
        document.getElementById('selected-run-timestamp').textContent = '‚Äî';
    }
    selectedRunInfo.style.display = 'block';
    
    // Enable submit button
    dataSubmitBtn.disabled = false;
    
    closeRunBrowser();
}

// Confirm run selection and immediately open plot viewer (for double-click)
function confirmRunSelectionAndView() {
    if (browserSelectedRuns.length === 0) return;
    
    // Store selected runs
    selectedRuns = [...browserSelectedRuns];
    selectedRun = selectedRuns[0];
    selectedRunInput.value = selectedRuns.map(r => r.run_number).join(',');
    
    // Update selection display
    if (selectedRuns.length === 1) {
        selectedRunNumber.textContent = selectedRuns[0].run_number;
        document.getElementById('selected-run-title').textContent = selectedRuns[0].title || '‚Äî';
        document.getElementById('selected-run-duration').textContent = selectedRuns[0].duration_display || '‚Äî';
        document.getElementById('selected-run-timestamp').textContent = selectedRuns[0].start_time_display || selectedRuns[0].timestamp_display || '‚Äî';
    } else {
        selectedRunNumber.textContent = selectedRuns.map(r => r.run_number).join(', ');
        document.getElementById('selected-run-title').textContent = `${selectedRuns.length} runs selected`;
        document.getElementById('selected-run-duration').textContent = '‚Äî';
        document.getElementById('selected-run-timestamp').textContent = '‚Äî';
    }
    selectedRunInfo.style.display = 'block';
    
    // Enable submit button
    dataSubmitBtn.disabled = false;
    
    // Set plot viewer variables
    currentRunNumbers = selectedRuns.map(r => r.run_number);
    currentRunNumber = currentRunNumbers[0];  // Backward compat
    currentStateId = stateSelect.value;
    
    // Close run browser and open plot viewer
    closeRunBrowser();
    openPlotViewer();
}

// Clear run selection
function clearRunSelection() {
    selectedRun = null;
    selectedRuns = [];
    browserSelectedRuns = [];
    selectedRunInput.value = '';
    selectedRunInfo.style.display = 'none';
    dataSubmitBtn.disabled = true;
}

// Escape HTML to prevent XSS
function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Set up filter event listeners
if (filterSearch) filterSearch.addEventListener('input', applyFiltersAndSort);
if (filterDuration) filterDuration.addEventListener('change', applyFiltersAndSort);
if (filterRun) filterRun.addEventListener('input', applyFiltersAndSort);

// Set up sort click handlers
document.querySelectorAll('.run-table th.sortable').forEach(th => {
    th.addEventListener('click', function() {
        const newSort = this.dataset.sort;
        if (newSort === sortColumn) {
            sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
        } else {
            sortColumn = newSort;
            sortDirection = 'asc';
        }
        applyFiltersAndSort();
    });
});

// Set up select-all checkbox
document.getElementById('select-all-runs')?.addEventListener('change', function() {
    const checked = this.checked;
    filteredRuns.forEach(run => {
        if (checked) {
            if (!browserSelectedRuns.some(r => r.run_number === run.run_number)) {
                browserSelectedRuns.push(run);
            }
        } else {
            browserSelectedRuns = browserSelectedRuns.filter(r => r.run_number !== run.run_number);
        }
    });
    updateSelectionCount();
    renderRunTable();
});

// Close modal on escape key
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        if (runBrowserModal.style.display === 'flex') {
            closeRunBrowser();
        }
        if (plotViewerModal && plotViewerModal.style.display === 'flex') {
            closePlotViewer();
        }
    }
});

// Close modal on backdrop click
runBrowserModal?.addEventListener('click', function(e) {
    if (e.target === this) {
        closeRunBrowser();
    }
});

// =============================================================================
// Plot Viewer Logic
// =============================================================================

const plotViewerModal = document.getElementById('plot-viewer-modal');
const plotContainer = document.getElementById('plot-container');
const workspaceSelect = document.getElementById('workspace-select');
const spectrumSelectGroup = document.getElementById('spectrum-select-group');
const dataForm = document.getElementById('data-form');

let currentPlotData = null;  // Current full plot data from API (may contain multi-run data)
let currentRunNumber = null;  // Single run (backward compat)
let currentRunNumbers = [];   // Array of run numbers for multi-run plotting
let currentStateId = null;

// Handle data form submission - open plot viewer
if (dataForm) {
    dataForm.addEventListener('submit', function(e) {
        e.preventDefault();
        if (selectedRuns.length === 0 && !selectedRun) {
            alert('Please select a run first');
            return;
        }
        currentRunNumbers = selectedRuns.length > 0 ? selectedRuns.map(r => r.run_number) : [selectedRun.run_number];
        currentRunNumber = currentRunNumbers[0];
        currentStateId = stateSelect.value;
        openPlotViewer();
    });
}

// Open the plot viewer modal
function openPlotViewer() {
    plotViewerModal.style.display = 'flex';
    
    // Update title based on number of runs
    if (currentRunNumbers.length > 1) {
        document.getElementById('plot-viewer-title').textContent = `üìä Runs ${currentRunNumbers.join(', ')}`;
    } else {
        document.getElementById('plot-viewer-title').textContent = `üìä Run ${currentRunNumber}`;
    }
    
    plotContainer.innerHTML = '<div class="loading-spinner">Loading plot data...</div>';
    
    // Reset workspace selector
    workspaceSelect.value = 'dsp_all';  // Default to combined view
    spectrumSelectGroup.style.display = 'none';
    
    // Load plot data
    loadPlotData('dsp_all');
}

// Close the plot viewer modal
function closePlotViewer() {
    plotViewerModal.style.display = 'none';
    currentPlotData = null;
}

// =========================================================================
// Plot Data Cache - prevents redundant API calls
// =========================================================================
const plotDataCache = new Map();
const CACHE_EXPIRY_MS = 5 * 60 * 1000;  // 5 minutes

function getCacheKey(runNumber, stateId, workspace) {
    return `${runNumber}-${stateId}-${workspace}`;
}

function getMultiCacheKey(runNumbers, stateId, workspace) {
    return `multi-${runNumbers.sort().join(',')}-${stateId}-${workspace}`;
}

function getCachedData(cacheKey) {
    const cached = plotDataCache.get(cacheKey);
    if (cached && (Date.now() - cached.timestamp) < CACHE_EXPIRY_MS) {
        return cached.data;
    }
    if (cached) {
        plotDataCache.delete(cacheKey);  // Expired
    }
    return null;
}

function setCachedData(cacheKey, data) {
    plotDataCache.set(cacheKey, {
        data: data,
        timestamp: Date.now()
    });
}

// Load plot data from API (supports multi-run) with caching
function loadPlotData(workspaceType) {
    plotContainer.innerHTML = '<div class="loading-spinner">Loading plot data...</div>';
    
    // Build cache key and check cache
    let cacheKey;
    let url;
    
    if (currentRunNumbers.length > 1) {
        cacheKey = getMultiCacheKey(currentRunNumbers, currentStateId, workspaceType);
        const runParams = currentRunNumbers.map(r => `runs=${r}`).join('&');
        url = `/entries/api/runs/multi/plot-data?${runParams}&state_id=${currentStateId}&workspace=${workspaceType}`;
    } else {
        cacheKey = getCacheKey(currentRunNumber, currentStateId, workspaceType);
        url = `/entries/api/runs/${currentRunNumber}/plot-data?state_id=${currentStateId}&workspace=${workspaceType}`;
    }
    
    // Check cache first
    const cachedData = getCachedData(cacheKey);
    if (cachedData) {
        console.log('Using cached plot data for', cacheKey);
        currentPlotData = cachedData;
        renderPlot(cachedData);
        updatePlotInfo(cachedData);
        return;
    }
    
    fetch(url)
        .then(res => res.json())
        .then(data => {
            if (data.error) {
                plotContainer.innerHTML = `<div class="error-message">Error: ${data.error}</div>`;
                return;
            }
            // Cache the data
            setCachedData(cacheKey, data);
            currentPlotData = data;
            renderPlot(data);
            updatePlotInfo(data);
        })
        .catch(err => {
            plotContainer.innerHTML = `<div class="error-message">Failed to load plot data: ${err}</div>`;
            console.error('Plot data error:', err);
        });
}

// Render the plot using Plotly
function renderPlot(data) {
    const traces = [];
    const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
    
    // Determine title based on data type
    let title;
    if (data.type === 'multi') {
        const runNums = data.runs.filter(r => !r.error).map(r => r.run_number);
        title = runNums.length > 3 
            ? `Runs ${runNums.slice(0, 3).join(', ')}... (${runNums.length} total) - d-spacing`
            : `Runs ${runNums.join(', ')} - d-spacing`;
    } else {
        title = `Run ${currentRunNumber} - d-spacing`;
    }
    
    const layout = {
        title: title,
        xaxis: { title: 'd (√Ö)', type: 'linear' },
        yaxis: { title: 'Intensity (arb. units)', type: 'linear' },
        showlegend: true,
        legend: { x: 1, xanchor: 'right', y: 1 },
        margin: { l: 60, r: 30, t: 40, b: 45 },
        hovermode: 'closest',
        autosize: true,
    };
    
    // Apply saved zoom range if available (from expanding a timeline entry)
    if (initialXRange) {
        layout.xaxis.range = initialXRange;
    }
    if (initialYRange) {
        layout.yaxis.range = initialYRange;
    }
    
    const config = {
        responsive: true,
        displayModeBar: true,
        modeBarButtonsToRemove: ['lasso2d', 'select2d'],
        displaylogo: false,
    };
    
    if (data.type === 'multi') {
        // Multi-run overlay plot
        // Check if any run has 2d data (multi-spectrum)
        const has2dData = data.runs.some(r => r.type === '2d');
        
        if (has2dData) {
            // Show spectrum selector for multi-spectrum data
            const firstRun = data.runs.find(r => r.type === '2d');
            if (firstRun) {
                populateSpectrumCheckboxes(firstRun.num_spectra, firstRun.name);
                spectrumSelectGroup.style.display = 'flex';
            }
            // Render with all spectra (will sum across spectra for each run)
            renderMultiRunPlot(data, null);  // null = all spectra
        } else {
            spectrumSelectGroup.style.display = 'none';
            renderMultiRunPlot(data, null);
        }
        
        initialXRange = null;
        initialYRange = null;
        
    } else if (data.type === '1d') {
        // Single spectrum plot (Combined/All Pixels) - no spectrum selector needed
        const x = data.x.filter((_, i) => data.y[i] !== null);
        const y = data.y.filter(v => v !== null);
        traces.push({
            x: x,
            y: y,
            type: 'scatter',
            mode: 'lines',
            name: 'Combined',
            line: { width: 1.5, color: colors[0] },
        });
        spectrumSelectGroup.style.display = 'none';
        
        Plotly.newPlot(plotContainer, traces, layout, config);
        
        // Clear initial zoom after applying (so fresh views aren't affected)
        initialXRange = null;
        initialYRange = null;
        
    } else if (data.type === '2d') {
        // Multi-spectrum plot - populate checkboxes and render all by default
        populateSpectrumCheckboxes(data.num_spectra, data.name);
        spectrumSelectGroup.style.display = 'flex';
        
        // Render with all spectra selected
        const allIndices = Array.from({length: data.num_spectra}, (_, i) => i);
        renderPlotWithSelection(data, allIndices);
        
    } else if (data.type === 'group') {
        // Overview of all workspaces - plot the 'all' one by default
        const allWs = data.workspaces.find(w => w.name.includes('dsp_all'));
        if (allWs) {
            const x = allWs.x.filter((_, i) => allWs.y[i] !== null);
            const y = allWs.y.filter(v => v !== null);
            traces.push({
                x: x,
                y: y,
                type: 'scatter',
                mode: 'lines',
                name: 'Combined (all pixels)',
                line: { width: 1.5, color: colors[0] },
            });
        }
        spectrumSelectGroup.style.display = 'none';
        
        Plotly.newPlot(plotContainer, traces, layout, config);
        
        // Clear initial zoom after applying
        initialXRange = null;
        initialYRange = null;
    }
}

// Get a user-friendly name for the workspace
function getWorkspaceDisplayName(name) {
    if (name.includes('dsp_all')) return 'Combined (all pixels)';
    if (name.includes('dsp_bank')) return 'Per Bank';
    if (name.includes('dsp_column')) return 'Per Column';
    return name;
}

// Get spectrum label based on workspace type
function getSpectrumLabel(wsName, index) {
    if (wsName && wsName.includes('dsp_bank')) {
        return `Bank ${index + 1}`;
    }
    if (wsName && wsName.includes('dsp_column')) {
        return `Column ${index + 1}`;
    }
    return `Spectrum ${index + 1}`;
}

// Get short spectrum label for legend
function getShortSpectrumLabel(wsName, index) {
    if (wsName && wsName.includes('dsp_bank')) {
        return `Bank ${index + 1}`;
    }
    if (wsName && wsName.includes('dsp_column')) {
        return `Col ${index + 1}`;
    }
    return `Sp ${index + 1}`;
}

// Populate the spectrum checkboxes
function populateSpectrumCheckboxes(numSpectra, wsName) {
    const container = document.getElementById('spectrum-checkboxes');
    container.innerHTML = '';
    
    for (let i = 0; i < numSpectra; i++) {
        const label = getSpectrumLabel(wsName, i);
        const checkbox = document.createElement('label');
        checkbox.className = 'spectrum-checkbox';
        checkbox.innerHTML = `
            <input type="checkbox" value="${i}" checked onchange="updatePlotFromCheckboxes()">
            <span>${label}</span>
        `;
        container.appendChild(checkbox);
    }
}

// Get selected spectrum indices from checkboxes
function getSelectedSpectra() {
    const checkboxes = document.querySelectorAll('#spectrum-checkboxes input[type="checkbox"]:checked');
    return Array.from(checkboxes).map(cb => parseInt(cb.value));
}

// Update plot based on checkbox selection
function updatePlotFromCheckboxes() {
    if (!currentPlotData) return;
    
    const selectedIndices = getSelectedSpectra();
    if (selectedIndices.length === 0) {
        plotContainer.innerHTML = '<div class="error-message">Select at least one spectrum to display</div>';
        return;
    }
    
    if (currentPlotData.type === 'multi') {
        // Multi-run with spectrum selection
        renderMultiRunPlot(currentPlotData, selectedIndices);
    } else if (currentPlotData.type === '2d') {
        // Single-run multi-spectrum
        renderPlotWithSelection(currentPlotData, selectedIndices);
    }
}

// Render multi-run plot with optional spectrum selection
function renderMultiRunPlot(data, selectedSpectra) {
    const traces = [];
    const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
    
    const runNums = data.runs.filter(r => !r.error).map(r => r.run_number);
    const title = runNums.length > 3 
        ? `Runs ${runNums.slice(0, 3).join(', ')}... (${runNums.length} total) - d-spacing`
        : `Runs ${runNums.join(', ')} - d-spacing`;
    
    const layout = {
        title: title,
        xaxis: { title: 'd (√Ö)', type: 'linear' },
        yaxis: { title: 'Intensity (arb. units)', type: 'linear' },
        showlegend: true,
        legend: { x: 1, xanchor: 'right', y: 1 },
        margin: { l: 60, r: 30, t: 40, b: 45 },
        hovermode: 'closest',
        autosize: true,
    };
    
    // Apply saved zoom range if available
    if (initialXRange) {
        layout.xaxis.range = initialXRange;
    }
    if (initialYRange) {
        layout.yaxis.range = initialYRange;
    }
    
    // Helper function to filter aligned x/y pairs
    function filterValidPairs(xArr, yArr) {
        const validX = [];
        const validY = [];
        for (let j = 0; j < yArr.length; j++) {
            if (yArr[j] !== null && !isNaN(yArr[j])) {
                validX.push(xArr[j]);
                validY.push(yArr[j]);
            }
        }
        return { x: validX, y: validY };
    }
    
    data.runs.forEach((runData, idx) => {
        if (runData.error) {
            console.warn(`Run ${runData.run_number}: ${runData.error}`);
            return;
        }
        
        const color = colors[idx % colors.length];
        
        if (runData.type === '1d') {
            const filtered = filterValidPairs(runData.x, runData.y);
            if (filtered.x.length > 0) {
                traces.push({
                    x: filtered.x,
                    y: filtered.y,
                    type: 'scatter',
                    mode: 'lines',
                    name: `Run ${runData.run_number}`,
                    line: { width: 1.5, color: color },
                });
            }
        } else if (runData.type === '2d') {
            // Multi-spectrum: create separate trace for each selected spectrum
            const numSpectra = runData.num_spectra;
            const indices = selectedSpectra || Array.from({length: numSpectra}, (_, i) => i);
            
            // Create a trace for each spectrum
            indices.forEach((specIdx, specOffset) => {
                if (specIdx >= numSpectra || !runData.y[specIdx]) {
                    return;
                }
                
                // Use the x array for this spectrum (or x[0] if all x arrays are the same)
                const xArr = Array.isArray(runData.x[specIdx]) ? runData.x[specIdx] : runData.x[0];
                const yArr = runData.y[specIdx];
                const filtered = filterValidPairs(xArr, yArr);
                
                if (filtered.x.length > 0) {
                    // Generate unique color for each run+spectrum combo
                    const colorIdx = (idx * indices.length + specOffset) % colors.length;
                    traces.push({
                        x: filtered.x,
                        y: filtered.y,
                        type: 'scatter',
                        mode: 'lines',
                        name: `Run ${runData.run_number} Spec ${specIdx + 1}`,
                        line: { width: 1.5, color: colors[colorIdx] },
                    });
                }
            });
        }
    });
    
    if (traces.length === 0) {
        plotContainer.innerHTML = '<div class="error-message">No valid data to plot</div>';
        return;
    }
    
    const config = {
        responsive: true,
        displayModeBar: true,
        modeBarButtonsToRemove: ['lasso2d', 'select2d'],
        displaylogo: false,
    };
    
    Plotly.newPlot(plotContainer, traces, layout, config);
}

// Render plot with specific spectrum selection (single-run 2d)
function renderPlotWithSelection(data, selectedIndices) {
    const traces = [];
    const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b'];
    
    const layout = {
        title: `Run ${currentRunNumber} - d-spacing`,
        xaxis: { title: 'd (√Ö)', type: 'linear' },
        yaxis: { title: 'Intensity (arb. units)', type: 'linear' },
        showlegend: true,
        legend: { x: 1, xanchor: 'right', y: 1 },
        margin: { l: 60, r: 30, t: 40, b: 45 },
        hovermode: 'closest',
        autosize: true,
    };
    
    // Apply saved zoom range if available
    if (initialXRange) {
        layout.xaxis.range = initialXRange;
    }
    if (initialYRange) {
        layout.yaxis.range = initialYRange;
    }
    
    console.log('renderPlotWithSelection: num_spectra =', data.num_spectra, 'selectedIndices =', selectedIndices);
    
    for (const i of selectedIndices) {
        if (i >= data.num_spectra) {
            console.warn('Spectrum index', i, 'out of range (num_spectra =', data.num_spectra, ')');
            continue;
        }
        
        const xArr = data.x[i];
        const yArr = data.y[i];
        
        if (!xArr || !yArr) {
            console.warn('Missing data for spectrum', i);
            continue;
        }
        
        // Filter out null values while keeping x/y pairs aligned
        const validPairs = [];
        for (let j = 0; j < yArr.length; j++) {
            if (yArr[j] !== null && !isNaN(yArr[j])) {
                validPairs.push({ x: xArr[j], y: yArr[j] });
            }
        }
        
        if (validPairs.length === 0) {
            console.warn('No valid data points for spectrum', i);
            continue;
        }
        
        console.log('Spectrum', i, ': adding', validPairs.length, 'points, x range:', validPairs[0].x, 'to', validPairs[validPairs.length-1].x);
        
        traces.push({
            x: validPairs.map(p => p.x),
            y: validPairs.map(p => p.y),
            type: 'scatter',
            mode: 'lines',
            name: getShortSpectrumLabel(data.name, i),
            line: { width: 1.5, color: colors[i % colors.length] },
        });
    }
    
    console.log('Total traces created:', traces.length);
    
    if (traces.length === 0) {
        plotContainer.innerHTML = '<div class="error-message">No valid data to display</div>';
        return;
    }
    
    const config = {
        responsive: true,
        displayModeBar: true,
        modeBarButtonsToRemove: ['lasso2d', 'select2d'],
        displaylogo: false,
    };
    
    Plotly.newPlot(plotContainer, traces, layout, config);
    
    // Clear initial zoom after applying
    initialXRange = null;
    initialYRange = null;
}

// Update plot info display
function updatePlotInfo(data) {
    const runInfo = document.getElementById('plot-run-info');
    const fileInfo = document.getElementById('plot-file-info');
    
    if (runInfo && selectedRun) {
        runInfo.textContent = `Run ${currentRunNumber}: ${selectedRun.title || 'Untitled'}`;
    }
    if (fileInfo && data.reduced_file) {
        fileInfo.textContent = data.reduced_file.split('/').slice(-2).join('/');
    }
}

// Handle workspace selector change
if (workspaceSelect) {
    workspaceSelect.addEventListener('change', function() {
        loadPlotData(this.value);
    });
}

// Capture plot as PNG using Plotly.toImage
async function captureSnapshot(plotDiv) {
    try {
        const imageData = await Plotly.toImage(plotDiv, {
            format: 'png',
            width: 800,
            height: 400,
            scale: 2  // Higher resolution for retina displays
        });
        return imageData;
    } catch (err) {
        console.error('Failed to capture snapshot:', err);
        return null;
    }
}

// Upload snapshot image to server
async function uploadSnapshot(imageData) {
    try {
        const response = await fetch('/entries/api/upload-snapshot', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ image_data: imageData })
        });
        const result = await response.json();
        if (result.success) {
            return result.filename;
        } else {
            console.error('Snapshot upload failed:', result.error);
            return null;
        }
    } catch (err) {
        console.error('Failed to upload snapshot:', err);
        return null;
    }
}

// Add current plot to timeline as a data entry
async function addPlotToTimeline() {
    // Check for runs - support both single and multi-run
    const runNumbers = currentRunNumbers.length > 0 ? currentRunNumbers : (currentRunNumber ? [currentRunNumber] : []);
    
    if (runNumbers.length === 0) {
        alert('No run selected');
        return;
    }
    
    // Use currentStateId (set when plot was opened) - more reliable than reading dropdown
    if (!currentStateId) {
        alert('No state selected. Please select a run from the browser first.');
        return;
    }
    
    const workspace = workspaceSelect.value;
    
    // Get selected spectra for both single-run 2d and multi-run with 2d data
    let selectedSpectra = [];
    if (currentPlotData) {
        if (currentPlotData.type === '2d') {
            selectedSpectra = getSelectedSpectra();
        } else if (currentPlotData.type === 'multi') {
            // Check if any run has 2d data
            const has2dData = currentPlotData.runs.some(r => r.type === '2d');
            if (has2dData) {
                selectedSpectra = getSelectedSpectra();
            }
        }
    }
    
    // Capture current zoom range from the plot
    let xRange = null;
    let yRange = null;
    const plotDiv = document.getElementById('plot-container');
    if (plotDiv && plotDiv.layout) {
        const xaxis = plotDiv.layout.xaxis;
        const yaxis = plotDiv.layout.yaxis;
        if (xaxis && xaxis.range) {
            xRange = xaxis.range;
        }
        if (yaxis && yaxis.range) {
            yRange = yaxis.range;
        }
    }
    
    // Prompt for optional note
    const note = prompt('Add a note (optional):', '');
    
    const btn = document.getElementById('add-to-timeline-btn');
    const originalText = btn.textContent;
    btn.textContent = 'Capturing...';
    btn.disabled = true;
    
    // Capture and upload snapshot
    let snapshotFilename = null;
    if (plotDiv) {
        btn.textContent = 'Capturing snapshot...';
        const imageData = await captureSnapshot(plotDiv);
        if (imageData) {
            btn.textContent = 'Uploading snapshot...';
            snapshotFilename = await uploadSnapshot(imageData);
        }
    }
    
    btn.textContent = 'Saving...';
    
    // Build request body - support both single and multi-run
    const requestBody = {
        state_id: currentStateId,
        workspace: workspace,
        selected_spectra: selectedSpectra,
        x_range: xRange,
        y_range: yRange,
        note: note || '',
    };
    
    // Include snapshot filename if captured
    if (snapshotFilename) {
        requestBody.snapshot = snapshotFilename;
    }
    
    if (runNumbers.length === 1) {
        requestBody.run_number = runNumbers[0];
    } else {
        requestBody.run_numbers = runNumbers;
    }
    
    fetch('/entries/api/create/data', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(requestBody)
    })
    .then(res => res.json())
    .then(data => {
        if (data.success) {
            // Close modal and dynamically add entry to timeline instead of full reload
            closePlotViewer();
            
            // Fetch and append the new entry HTML with snapshot
            fetchAndAppendNewEntry(data.entry_id, runNumbers, currentStateId, workspace, selectedSpectra, xRange, yRange, snapshotFilename, note);
            
            btn.textContent = originalText;
            btn.disabled = false;
        } else {
            alert('Error: ' + (data.error || 'Failed to create entry'));
            btn.textContent = originalText;
            btn.disabled = false;
        }
    })
    .catch(err => {
        console.error('Failed to add to timeline:', err);
        alert('Failed to add to timeline. Check console for details.');
        btn.textContent = originalText;
        btn.disabled = false;
    });
}

// Dynamically add new entry to timeline without full reload
function fetchAndAppendNewEntry(entryId, runNumbers, stateId, workspace, selectedSpectra, xRange, yRange, snapshotFilename, note) {
    // Create a simple entry card for the new data entry
    const timeline = document.getElementById('timeline');
    if (!timeline) return;
    
    const isMulti = runNumbers.length > 1;
    const runBadges = isMulti 
        ? runNumbers.slice(0, 5).map(r => `<span class="data-run-badge">Run ${r}</span>`).join('') 
          + (runNumbers.length > 5 ? `<span class="data-run-badge">+${runNumbers.length - 5} more</span>` : '')
        : `<span class="data-run-badge">Run ${runNumbers[0]}</span>`;
    
    // Build onclick handler - needs careful escaping
    let onclickHandler;
    if (isMulti) {
        onclickHandler = `openPlotViewerForMultiEntry([${runNumbers.join(',')}], '${stateId}', '${workspace}', ${xRange ? '[' + xRange.join(',') + ']' : 'null'}, ${yRange ? '[' + yRange.join(',') + ']' : 'null'})`;
    } else {
        onclickHandler = `openPlotViewerForEntry(${runNumbers[0]}, '${stateId}', '${workspace}', ${xRange ? '[' + xRange.join(',') + ']' : 'null'}, ${yRange ? '[' + yRange.join(',') + ']' : 'null'})`;
    }
    
    // Build the plot display: snapshot image if available, otherwise placeholder
    let plotDisplay;
    if (snapshotFilename) {
        plotDisplay = `
            <div class="data-snapshot-container">
                <img src="/entries/uploads/${snapshotFilename}" 
                     alt="Plot snapshot for Run ${runNumbers[0]}"
                     class="data-snapshot-image"
                     loading="lazy">
            </div>
        `;
    } else {
        plotDisplay = `
            <div class="data-plot-placeholder">
                <div class="placeholder-content">
                    <span class="placeholder-icon">üìä</span>
                    <span class="placeholder-text">Click Expand to load plot</span>
                </div>
            </div>
        `;
    }
    
    // Build note display if provided
    const noteHtml = note ? `<div class="data-note">${escapeHtml(note)}</div>` : '';
    
    const entryHtml = `
        <article class="entry-card entry-type-data" id="entry-${entryId}">
            <div class="entry-header">
                <span class="entry-type-badge">üìä data</span>
                <time class="entry-timestamp">${new Date().toLocaleString()}</time>
            </div>
            <h3 class="entry-title">${isMulti ? `Runs ${runNumbers.slice(0, 3).join(', ')}${runNumbers.length > 3 ? '...' : ''}` : `Run ${runNumbers[0]}`}</h3>
            <div class="entry-body">
                <div class="data-entry-content">
                    <div class="data-entry-info">
                        ${runBadges}
                        <span class="data-workspace-badge">${workspace}</span>
                    </div>
                    ${noteHtml}
                    ${plotDisplay}
                    <div class="data-entry-actions">
                        <button type="button" class="btn btn-sm btn-secondary" 
                                onclick="${onclickHandler}">
                            üîç Expand
                        </button>
                    </div>
                </div>
            </div>
        </article>
    `;
    
    // Insert at the end of the timeline
    timeline.insertAdjacentHTML('beforeend', entryHtml);
    
    // Scroll to the new entry
    const newEntry = document.getElementById(`entry-${entryId}`);
    if (newEntry) {
        newEntry.scrollIntoView({ behavior: 'smooth', block: 'end' });
    }
}

// Helper function to escape HTML in user input
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Close plot viewer modal on backdrop click
plotViewerModal?.addEventListener('click', function(e) {
    if (e.target === this) {
        closePlotViewer();
    }
});

// =========================================================================
// Timeline Data Entry Plots
// =========================================================================

// Store initial zoom range for when plot viewer opens from an entry
let initialXRange = null;
let initialYRange = null;

// Open plot viewer for an existing entry (expand button)
function openPlotViewerForEntry(runNumber, stateId, workspace, xRange, yRange) {
    // Set up the state for plot viewer
    const stateSelect = document.getElementById('state-select');
    if (stateSelect) {
        stateSelect.value = stateId;
    }
    
    // Create a minimal selectedRun object
    selectedRun = {
        run_number: runNumber,
        title: '',  // Will be populated when plot loads
    };
    currentRunNumber = runNumber;
    currentRunNumbers = [runNumber];  // Single run as array
    currentStateId = stateId;  // Must set this for loadPlotData to work
    
    // Store initial zoom range to apply after plot loads
    initialXRange = xRange || null;
    initialYRange = yRange || null;
    
    // Set workspace selector
    if (workspaceSelect) {
        workspaceSelect.value = workspace;
    }
    
    // Open viewer and load data
    plotViewerModal.style.display = 'flex';
    document.getElementById('plot-viewer-title').textContent = `üìä Run ${runNumber}`;
    loadPlotData(workspace);
}

// Open plot viewer for a multi-run entry (expand button)
function openPlotViewerForMultiEntry(runNumbers, stateId, workspace, xRange, yRange) {
    // Set up the state for plot viewer
    const stateSelect = document.getElementById('state-select');
    if (stateSelect) {
        stateSelect.value = stateId;
    }
    
    currentRunNumber = runNumbers[0];  // First run as primary
    currentRunNumbers = runNumbers;     // All runs for multi-plot
    currentStateId = stateId;
    
    // Store initial zoom range to apply after plot loads
    initialXRange = xRange || null;
    initialYRange = yRange || null;
    
    // Set workspace selector
    if (workspaceSelect) {
        workspaceSelect.value = workspace;
    }
    
    // Open viewer and load data
    plotViewerModal.style.display = 'flex';
    const title = runNumbers.length <= 3 
        ? `üìä Runs ${runNumbers.join(', ')}`
        : `üìä Runs ${runNumbers.slice(0, 3).join(', ')}... (${runNumbers.length} total)`;
    document.getElementById('plot-viewer-title').textContent = title;
    loadPlotData(workspace);
}

// Render a plot in the timeline with caching support
function renderTimelinePlot(container) {
    const runNumber = parseInt(container.dataset.run);
    const runsData = container.dataset.runs;
    const runNumbers = runsData ? JSON.parse(runsData) : [runNumber];
    const isMultiRun = runNumbers.length > 1;
    const stateId = container.dataset.state;
    const workspace = container.dataset.workspace;
    const selectedSpectra = JSON.parse(container.dataset.spectra || '[]');
    
    // Get saved zoom range if available
    const xRangeStr = container.dataset.xRange;
    const yRangeStr = container.dataset.yRange;
    const xRange = (xRangeStr && xRangeStr !== 'null') ? JSON.parse(xRangeStr) : null;
    const yRange = (yRangeStr && yRangeStr !== 'null') ? JSON.parse(yRangeStr) : null;
    
    renderTimelinePlotWithCache(container, runNumbers, stateId, workspace, selectedSpectra, xRange, yRange);
}

// Core timeline plot render function that uses cache
function renderTimelinePlotWithCache(container, runNumbers, stateId, workspace, selectedSpectra, xRange, yRange) {
    const isMultiRun = runNumbers.length > 1;
    
    // Check cache first
    const cacheKey = isMultiRun 
        ? getMultiCacheKey(runNumbers, stateId, workspace)
        : getCacheKey(runNumbers[0], stateId, workspace);
    
    const cachedData = getCachedData(cacheKey);
    if (cachedData) {
        console.log('Using cached data for timeline plot:', cacheKey);
        renderTimelinePlotFromData(container, cachedData, runNumbers, selectedSpectra, xRange, yRange, isMultiRun);
        return;
    }
    
    container.innerHTML = '<div class="plot-loading">Loading...</div>';
    
    // Choose endpoint based on single or multi-run
    const url = isMultiRun
        ? `/entries/api/runs/multi/plot-data?state_id=${stateId}&workspace=${workspace}&${runNumbers.map(r => `runs=${r}`).join('&')}`
        : `/entries/api/runs/${runNumbers[0]}/plot-data?state_id=${stateId}&workspace=${workspace}`;
    
    fetch(url)
        .then(res => res.json())
        .then(data => {
            if (data.error) {
                container.innerHTML = `<div class="plot-loading" style="color: #dc2626;">Error: ${data.error}</div>`;
                return;
            }
            
            // Cache the data
            setCachedData(cacheKey, data);
            
            renderTimelinePlotFromData(container, data, runNumbers, selectedSpectra, xRange, yRange, isMultiRun);
        })
        .catch(err => {
            console.error('Failed to load timeline plot:', err);
            container.innerHTML = '<div class="plot-loading" style="color: #dc2626;">Failed to load plot</div>';
        });
}

// Render timeline plot from data (extracted for reuse with cache)
function renderTimelinePlotFromData(container, data, runNumbers, selectedSpectra, xRange, yRange, isMultiRun) {
    const traces = [];
    const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b'];
    
    // Helper function to filter aligned x/y pairs
    function filterValidPairs(xArr, yArr) {
        const validX = [];
        const validY = [];
        for (let j = 0; j < yArr.length; j++) {
            if (yArr[j] !== null && !isNaN(yArr[j])) {
                validX.push(xArr[j]);
                validY.push(yArr[j]);
            }
        }
        return { x: validX, y: validY };
    }
    
    if (data.type === 'multi') {
        // Multi-run plot - one trace per run
        data.runs.forEach((runData, idx) => {
            if (runData.error) {
                console.warn(`Run ${runData.run_number}: ${runData.error}`);
                return;
            }
            
            const color = colors[idx % colors.length];
            
            if (runData.type === '1d') {
                const filtered = filterValidPairs(runData.x, runData.y);
                if (filtered.x.length > 0) {
                    traces.push({
                        x: filtered.x, y: filtered.y,
                        type: 'scatter',
                        mode: 'lines',
                        name: `Run ${runData.run_number}`,
                        line: { width: 1, color: color },
                    });
                }
            } else if (runData.type === '2d') {
                // For 2d data in multi-run, sum selected spectra
                const numSpectra = runData.num_spectra;
                const indices = selectedSpectra.length > 0 ? selectedSpectra : 
                                Array.from({length: numSpectra}, (_, i) => i);
                const xArr = runData.x[0];
                const ySum = xArr.map((_, i) => {
                    let sum = 0;
                    let hasValue = false;
                    for (const s of indices) {
                        if (s < numSpectra && runData.y[s] && runData.y[s][i] !== null && !isNaN(runData.y[s][i])) {
                            sum += runData.y[s][i];
                            hasValue = true;
                        }
                    }
                    return hasValue ? sum : null;
                });
                const filtered = filterValidPairs(xArr, ySum);
                
                if (filtered.x.length > 0) {
                    traces.push({
                        x: filtered.x, y: filtered.y,
                        type: 'scatter',
                        mode: 'lines',
                        name: `Run ${runData.run_number}`,
                        line: { width: 1, color: color },
                    });
                }
            }
        });
    } else if (data.type === '1d') {
        // Single spectrum
        const filtered = filterValidPairs(data.x, data.y);
        if (filtered.x.length > 0) {
            traces.push({
                x: filtered.x, y: filtered.y,
                type: 'scatter',
                mode: 'lines',
                name: 'Combined',
                line: { width: 1, color: colors[0] },
            });
        }
    } else if (data.type === '2d') {
        // Multi-spectrum - render selected or all
        const indices = selectedSpectra.length > 0 ? selectedSpectra : 
                        Array.from({length: data.num_spectra}, (_, i) => i);
        for (const i of indices) {
            if (i >= data.num_spectra) continue;
            const xArr = data.x[i];
            const yArr = data.y[i];
            if (!xArr || !yArr) continue;
            
            const filtered = filterValidPairs(xArr, yArr);
            if (filtered.x.length > 0) {
                traces.push({
                    x: filtered.x, y: filtered.y,
                    type: 'scatter',
                    mode: 'lines',
                    name: `Spectrum ${i}`,
                    line: { width: 1, color: colors[i % colors.length] },
                });
            }
        }
    }
    
    if (traces.length === 0) {
        container.innerHTML = '<div class="plot-loading" style="color: #dc2626;">No data to display</div>';
        return;
    }
    
    // Compact layout for timeline thumbnail
    const layout = {
        xaxis: { 
            title: { text: 'd (√Ö)', font: { size: 11 } },
            tickfont: { size: 10 },
        },
        yaxis: { 
            title: { text: 'I', font: { size: 11 } },
            tickfont: { size: 10 },
        },
        showlegend: isMultiRun && traces.length <= 4,  // Show legend for multi-run if few traces
        legend: { font: { size: 9 }, x: 0.98, xanchor: 'right', y: 0.98 },
        margin: { l: 45, r: 10, t: 5, b: 35 },
        hovermode: 'closest',
        autosize: true,
    };
    
    // Apply saved zoom range if available
    if (xRange) {
        layout.xaxis.range = xRange;
    }
    if (yRange) {
        layout.yaxis.range = yRange;
    }
    
    const config = {
        responsive: true,
        displayModeBar: false,
    };
    
    try {
        Plotly.newPlot(container, traces, layout, config);
    } catch (err) {
        console.error('Plotly error:', err);
        container.innerHTML = '<div class="plot-loading" style="color: #dc2626;">Plot render error</div>';
    }
}

// Initialize timeline on page load
// Note: Data entries with snapshots show static images - no data loading needed
// Only entries without snapshots (legacy or failed capture) have placeholder divs
document.addEventListener('DOMContentLoaded', function() {
    // No automatic data loading - snapshots are shown as static images
    // The "Expand" button will load interactive data when clicked
    console.log('Timeline loaded. Data entries show static snapshots.');
});

</script>
{% endblock %}
